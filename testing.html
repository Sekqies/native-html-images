<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const src = `
        @group(0) @binding(0) var<storage, read_write> data: array<f32>;
        @compute @workgroup_size(1) fn divide(@builtin(global_invocation_id) id: vec3u){
            let i = id.x;
            data[i] = data[i] / 2.0;
        }            
        `
        async function main(){
            const adapter = await navigator.gpu?.requestAdapter();
            const device = await adapter?.requestDevice();
            if(!device){
                fail("browser does not support WebGPU");
                return;
            }
            const module = device.createShaderModule({
                label: 'i am the one who divides',
                code: src
            });
            const pipeline = device.createComputePipeline({
                label: 'i am the one who pipelines',
                layout: 'auto',
                compute:{
                    module
                }
            })
            const input = new Float32Array([1,3,5]);
            const work_buffer = device.createBuffer({
                label: 'work buffer',
                size: input.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
            });
            device.queue.writeBuffer(work_buffer,0,input);
            const result_buffer = device.createBuffer({
                label: 'result buffer',
                size: input.byteLength,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
            })
            const bind_group = device.createBindGroup({
                label: 'bind group for work buffer',
                layout: pipeline.getBindGroupLayout(0),
                entries: [
                    {binding:0, resource: work_buffer}
                ]
            });
              const encoder = device.createCommandEncoder({
                label: 'doubling encoder',
            });
            const pass = encoder.beginComputePass({
                label: 'doubling compute pass',
            });
            pass.setPipeline(pipeline);
            pass.setBindGroup(0, bind_group);
            pass.dispatchWorkgroups(input.length);
            pass.end();
            encoder.copyBufferToBuffer(work_buffer, 0, result_buffer, 0, result_buffer.size);
            const commandBuffer = encoder.finish();
            device.queue.submit([commandBuffer]);

            await result_buffer.mapAsync(GPUMapMode.READ);
            const result = new Float32Array(result_buffer.getMappedRange());

            console.log('input',input);
            console.log('result',result);
            result_buffer.unmap();
        }
        main();






    </script>
</body>
</html>